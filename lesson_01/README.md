# Lesson 01 多人聊天室

## 执行示例
**为了避免任何bug，运行请切换到skynet目录下，然后执行**

### 服务端
``` bash
./skynet $your skynet config$
```

### 客户端
``` bash
3rd/lua/lua $your client.lua$
```

## 写给不懂程序的大佬的话

防杠声明，写这些内容不是为了装逼，更不是为了卷。如果没有内鬼，这个文件甚至不会被老师看到。我只是喜欢IMDT，喜欢大家，希望每个人都成为六边形战士，在经济下行的今天把自己变得更强。策划大佬能上手改代码，美术大佬能融入一点简单的逻辑，程序大佬能把自己的代码写的更好。

**我希望IMDT学生代表中国游戏科班的最高水平。**

### 基本概念
假设存在一个世界，这个世界上所有人都无法直接和其它人说话，想要说话必须通过一个中间的人传话。在我们的场景下，所有在聊天室的人想要把自己的话打在公屏上，必须通过一个中间传话的人。

**这个中间负责传话的人就是服务端，也就是chat_service.lua这个文件。**
服务端负责收集所有人要说的话，然后再把这些话打在每个人的公屏上，让每一个人看见。
没有服务端，就没有传话的人，也就没有公屏，大家就无法沟通，聊天室也就不存在了。
**所以，服务端是聊天室的核心，也是我们重点维护的对象。这次作业比较简单，我们只需要管理好chat_service.lua这一个文件。**

那么客户端，也就是每一个聊天的个体，如果想要加入这个聊天室，必须先和中间传话的人联系。这个联系的过程就是客户端和服务端建立连接的过程。这里完成这个联系的协议就是socket协议。（可以先把协议理解为一种规则，这个规则规定了客户端和服务端建立连接的过程。）
**客户端，我们只需要管理好client.lua这一个文件。**

当客户端连接上服务端之后，客户端就可以和服务端进行通信了。Skynet这个服务端框架帮助我们简化了这个过程，我们只需要把自己的消息发送给服务端，服务端就会把这个消息转发给所有的客户端。这个过程就是我们的聊天室的核心功能。

### 如何理解服务端原始代码

有了上面的铺垫，你已经大概理解聊天室的基本功能，以及我们在干什么。
而且聪明的你会思考，这个世界上需要一个中间传话的人，这样想说话的人才可以互相沟通，所以我们最好先去看看它的代码。

**下面，移步到chat_service.lua这个文件。**

``` lua
-- 启动服务器
function start_server()
    print("==========Socket Start=========")
    -- 监听一个端口，返回一个 id ，供 start 使用。
    local srv_id = socket.listen("127.0.0.1", 8888)
    print("Listen socket :", "127.0.0.1", 8888)

    socket.start(srv_id, handle_client)
end
```

这一段代码的作用是启动服务器，也就是启动chat_service.lua这个文件。至于这里面服务怎么启动，在哪个端口，这些需要更多的知识储备，我们先不管。这些名词我们先用起来，到后面自然会知道。
现在我们只需要知道，服务端在不断监听本机（你现在在使用的这台电脑）8888端口，如果有人想要加入聊天室就往8888端口说话就好。
**这里面最重要的是`socket.start(srv_id, handle_client)`这句代码，这行代码启动了服务端。并且，每当有一个用户加入这个服务器（聊天室），服务端会执行`handle_client`这个函数。**
就好比，你开了一家餐厅，你的服务员会一直在门口等着顾客，一旦有顾客进来，服务员就会去服务这个顾客。怎么服务呢？利用`handle_client`这个函数服务。所以我们最好先去看看它的代码。


``` lua
-- 接收到客户端连接或收到客户端消息
function handle_client(id, addr)
    print("connect from "..addr.." ".. id)
    skynet.error("handle_client service", coroutine.running())
    -- 任何一个服务只有在调用 socket.start(id) 之后，才可以收到这个 socket 上的数据。
    socket.start(id)

    while true do
        local str = socket.read(id)
        if str then
            print("client say:"..str)
            -- 把一个字符串置入正常的写队列，skynet 框架会在 socket 可写时发送它。
            socket.write(id, str)
        else
            print("handle_client-- over")
            socket.close(id)
            return
        end
    end
end
```
这一段是服务端的核心代码，表明了服务端是如何处理每一个客户端的请求。前面几行先不care，当顾客进入你的餐厅之后，你会给顾客一个号牌，唯一标识这个顾客。这个号牌就是`id`，`addr`是顾客的身份证号。
然后，你就会让服务员像跟屁虫一样一直粘着这个顾客，等着它说话。也就是我们看到的这个大循环，这个死循环。
`socket.read(id)`就是服务端一直在等着某个`id`的说话，一旦它说话了，就把它说的话`str`在**你自己的屏幕上**打出来！
**注意`print("client say:"..str)`这一行只是在你自己的屏幕上（服务端）打印出来，这个`str`并没有发送给其他人，这个`str`只是你自己看到的！顾客（客户端）还并不知道！**

下面的`socket.write(id, str)`才是真正将`str`发送给顾客的代码。这个`str`就是顾客刚刚说的话，你把它再发给顾客，这样顾客就知道自己说的话了（虽然很扯淡，但是就是这样）。

然后这个循环会一直循环下去，直到顾客走了，服务员才会停下来。

看，服务端就是这么简单，就是一个死循环，一直在等着顾客说话，一旦顾客说话了，就把它说的话再发给顾客。就是个臭传话的！

### 如何理解客户端原始代码
理解完服务端后，我们来理解客户端。
客户端，就是来餐厅的顾客，你领取了店家给你的号牌，看看会发生什么。
前面的代码，我们可以先不care，这还不在我们考虑范围。

```lua
local fd = assert(socket.connect("127.0.0.1", 8888))
 
socket.send(fd, "Hello world")
```
先看这两行。第一行，你去餐厅，店家给你一个号牌，这个号牌就是`fd`，然后你就可以和店家说话了。assert是什么你也不需要关心，这都不重要，因为我们大概率会成功！
**第二行，就像阅读英语一样，你给服务员说了一句话（注意第一个参数是`fd`，你需要告诉服务员你号牌的数字，然后你要说的内容）。这句话就是`Hello world`。**
学术一点说，你通过socket协议连接到了服务端，然后你通过标识为`fd`的这个信道，告诉服务端你传输的信息。

```lua
while true do
    -- 接收服务器返回消息
    local str  = socket.recv(fd)
    if str~=nil and str~="" then
            print("someone says: "..str)
            -- socket.close(fd)
            -- break;
    end
 
    -- 读取用户输入消息
    local readstr = socket.readstdin()
    if readstr then
        if readstr == "quit" then
            socket.close(fd)
            break;
        else
            -- 把用户输入消息发送给服务器
            socket.send(fd, readstr)
        end
    else
        socket.usleep(100)
    end
end
```
然后呢？你就加入这个聊天室里了，正式成为聊天室的一员。可以不断的说话。
这个while循环，就是你在聊天室里的生活。你可以不断的说话，也可以不断的听别人说话。**这也是个死循环，它的目的就是不断接收你在键盘上的输入。**（一会儿餐厅一会儿聊天室的，希望大家不要喷我）
那我们做了什么呢？
首先，来人家的聊天室，你得先听听人家说什么对吧？所以第一行，就是你在聊天室里听人家说话。**你通过`socket.recv(fd)`，告诉服务员你要听人家说话，然后服务员就会把人家说的话告诉你。**
诶！到这里，是不是就和服务端的代码对上了！？
**刚才说到，服务端通过`socket.write(id, str)`把客户端说的话传给客户端，客户端通过`socket.recv(fd)`接收服务端传来的话，然后打印出来（这里是打印在你自己的屏幕上了！）。这就是你在聊天室里听人家说话（现在还只有你一个人）的过程。**

然后听完服务端BB半天了，你要说话了，你怎么说呢？
**你通过`socket.readstdin()`，告诉服务员你要说话（从键盘上输入），然后服务员就会把你说的话传给服务端。**
当然，如果说的话是`quit`，socket就关掉了，收回你的号牌`fd`，你就离开了聊天室。
否则，把你从键盘上说的话，利用`fd`这个号牌，传给服务端。

到这里，你作为顾客，客户端的代码也写完了！是不是很简单！

### 小结
所以，回顾整个过程，我们用简洁的、更规范的语言来描述一下整个流程：

1. 启动服务端，监听8888端口；
2. 服务端在执行一个死循环，这个死循环不断监听8888端口。如果有客户端加入当前服务，会给予这个客户端唯一的一个标识`id`。**在客户端加入后，如果客户端发送了消息，服务端就会把这个消息再次转发给客户端。这个过程就是服务端的死循环在不断的执行。**
3. 客户端在通过8888端口连接到服务端后，会获取唯一一个标识`fd`（和`id`不一样，但是是一个意思）。**客户端然后执行一个死循环，先接收服务端传输的消息，再向服务端发送消息。这个过程就是客户端的死循环在不断的执行。**

## 如何进阶
那么，要完成作业，你还需要做什么呢？
我的代码里是一个多客户端聊天室。你大可直接抄袭，但我更相信你是一个宁愿做不出来也不要照搬的人。

### 基础作业提示
1. 为了在连接服务端后能有姓名，你需要从键盘上接收用户的输入，并且用一个变量把它存下来。
2. 每次服务端给客户端传输消息后，要表示是谁说的话，这件事情既可以在客户端做，也可以在服务端做，哪个更简单呢？

### 多人客户端提示
1. 有了多个客户端，服务端转发消息的时候，就不可以只转发给一个客户端，而是要转发给所有客户端。我们是使用不同的`id`来唯一标识每一个客户端，我们是不是应该把这些`id`存起来呢？
2. 当客户端连接上服务端之后，不同客户端会取不同的名字，这个可以在客户端做，也可以在服务端做，但是怎么做更好呢？
3. 服务端如何辨别客户端是加入还是说话呢？
4. 服务端要如何辨别客户端的退出呢？
